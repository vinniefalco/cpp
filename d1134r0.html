<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>An Elegant Coroutine Abstraction</title>
    <style type="text/css">
    p {text-align:justify}
    li {text-align:justify}
    blockquote.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    p.note
    {
        background-color:#E0E0E0;
        padding-left: 15px;
        padding-right: 15px;
        padding-top: 1px;
        padding-bottom: 1px;
    }
    ins { background-color: #CCFFCC; }
    del { background-color: #FFCCCC; }
    .insert { background-color: #CCFFCC; }
    address {text-align:right;}
    h1 {text-align:center;}
    span.comment {color:#C80000;}
    code {white-space:pre;}
    </style>
</head>
<body>
<pre>
Doc. no:  D1134R0
Audience: LEWG
Date:     2018-06-21
Reply-To: Vinnie Falco (<a href="mailto:vinnie.falco@gmail.com">vinnie.falco@gmail.com</a>)
</pre>
<hr>
<h1>An Elegant Coroutine Abstraction</h1>



<h2>Contents</h2>
<ul>
<li><a href="#Abstract">Abstract</a></li>
<li><a href="#Introduction">Introduction</a>
<li><a href="#History">History</a>
<li><a href="#Discussion">Discussion</a>
<li><a href="#Solution">Solution</a>
<li><a href="#References">References</a>
<li><a href="#Acknowledgements">Acknowledgements</a>
<li><a href="#Listing1">Listing 1</a>

</ul>



<a name="Abstract"></a><h2>Abstract</h2>
<p>
Coroutines enable authors to write code which may be suspended and resumed
at well defined locations without inverting the flow of control. A preponderance
of experience shows the need to add this as a language feature, as library-only
solutions cannot achieve comparable performance and clarity of expression for
some use cases. Unfortunately, the leading proposal for introducing coroutines
to the language suffers from significant design flaws. In this paper we
discuss the design flaws with current proposals, suggest an alternative,
and provide a framework for how coroutine proposals should be evaluated.
</p>



<a name="Introduction"></a><h2>Introduction</h2>
<p>
A <em>coroutine</em> is a thread of execution containing well-defined suspend
points from which the flow of control may be interrupted and resumed.
A <em>stackful</em> coroutine preserves the stack of the thread of execution
starting from the entry point to the suspend point. 
A <em>stackless</em> coroutine preserves a constant amount of state known
at compile time. Stackful coroutines are uncontroversial, many performant
implementations have existed as library-only solutions for decades. This
paper discusses stackless coroutines exclusively; henceforth they are
referred to simply as "coroutines".
</p>
<p>
All coroutine implementations share a common algorithm, called the
<em>coroutine transformation</em> (henceforth termed "transformation").
This algorithm takes ordinary code annotated with suspend points and
inserts additional code allowing the thread of execution to be interrupted
at each suspend point and later resumed. At a minimum, the transformation
must store sufficient state to identify the last suspend point from which
the coroutine should be resumed. An implementation may also choose to
preserve the values of some or all local variables and function arguments.
The following program shows an example of a coroutine:
</p>
<blockquote><tt><pre>
#include "coroutine.hpp"

#include &lt;iostream&gt;

struct hello : coroutine
{
    void operator()()
    {
        co_enter(*this)
        {
            co_await std::cout << "Hello, ";
            co_await std::cout << "world!";
            co_await std::cout.flush();
        }
    }
};

int main()
{
    hello c;

    while(! c.await_ready())
        c();
}
</pre></tt></blockquote>
<p>
In this example, which prints "Hello, world!", the coroutine is represented
by the function object <tt>hello</tt>. The coroutine starts out in the
suspended state, and is resumed by invoking the function call operator.
The <tt>co_enter</tt> keyword denotes the entry point into the coroutine
body, while the <tt>co_await</tt> keyword marks a suspension point. The
thread of execution will suspend (return to the caller) after the statement
or block following the <tt>co_await</tt> keyword executes.
</p>
<p>
It may be surprising to discover that the coroutine interface used above is
implemented entirely as a library solution, without help from the compiler.
The source code for the library header file "coroutine.hpp" may be seen in
<a href="#Listing1">Listing 1</a>. The <tt>co_enter</tt> and <tt>co_await</tt>
keywords are defined as macros. Performing the macro substitutions in the
function call operator definition above gives us insight into the structure
of the transformation:
</p>
<blockquote><tt><pre>
void operator()()
{
    switch (::detail::coroutine_ref _coro_value = *this)
    case -1: if (_coro_value)
    {
        goto terminate_coroutine;
        terminate_coroutine:
        _coro_value = -1;
        goto bail_out_of_coroutine;
        bail_out_of_coroutine:
        break;
    } else case 0:
    {
            for (_coro_value = (10);;) if (_coro_value == 0) {
        case (10): ; break; } else
            switch (_coro_value ? 0 : 1) for (;;)
            case -1: if (_coro_value) goto terminate_coroutine; else for (;;)
            case  1: if (_coro_value) goto bail_out_of_coroutine; else
            case  0:
        std::cout << "Hello, ";
            for (_coro_value = (11);;) if (_coro_value == 0) {
        case (11): ; break; } else
            switch (_coro_value ? 0 : 1) for (;;)
            case -1: if (_coro_value) goto terminate_coroutine; else for (;;)
            case  1: if (_coro_value) goto bail_out_of_coroutine; else
            case  0:
        std::cout << "world!";
            for (_coro_value = (12);;) if (_coro_value == 0) {
        case (12): ; break; } else
            switch (_coro_value ? 0 : 1) for (;;)
            case -1: if (_coro_value) goto terminate_coroutine; else for (;;)
            case  1: if (_coro_value) goto bail_out_of_coroutine; else
            case  0:
        std::cout.flush();
    }
}
</pre></tt></blockquote>
<p>
The code in Listing 1 is adapted from the stackless coroutine implementation
from Boost.Asio[1]. There are some notable limitations. The values of local
variables are not automatically preserved; they must be manually saved by
using class data members instead. Furthermore, due to the inserted
<tt>goto</tt> and <tt>switch</tt> statements, code blocks must be
arranged to avoid jumps across variable initializations.
</p>
<p>
Despite these limitations, this simple macro-based approach has a number of
strengths. The function is written without inverting the flow of control.
The coroutine is a plain struct. No dynamic allocations are performed, and
the user decides where and how the object is placed. A coroutine may be part
of a larger object which is itself a coroutine and also contains other
coroutines. This mechanism has been used in popular libraries such as
Boost.Beast[2], making complex asynchronous operations easier to express
and reason about.
</p>
<p>
This particular implementation is presented to demonstrate that assistance
from the compiler is not required to perform the coroutine transformation.
It can be expressed using existing C++ language constructs. The minimal set
of features a coroutine transformation must provide are as follows:
</p>
<ul>
<li>A means to annotate suspend points within a function</li>
<li>An object to represent the coroutine and its state</li>
<li>Interfaces to query and control the coroutine's execution</li>
</ul>
<p>
We use the term coroutine to also refer to the object produced by the
transformation, and the term <em>coroutine abstraction</em> (henceforth
termed "abstraction") to refer to the interface offered by a particular
implementation for creating and interacting with the coroutine. While an
abstraction may include additional features (such retaining local variables
across suspend points), these features are not required as demonstrated above.
An abstraction with no additional features is termed a <em>minimal abstraction</em>
</p>
<p>
While a minimal abstraction is functional, it is not something which typical
users would want to interact with directly. Most users want higher-level
abstractions such as futures, generators, and iterators. There is also great
interest in using coroutines with libraries that perform asynchronous
networking or other I/O. These higher level abstractions may be part of
a coroutine abstraction, or they can be provided as library components
built on a minimal abstraction. We use the term <em>coroutine middleware</em>
(or just "middleware") to describe additional language or library elements
whose functionality goes beyond the minimal abstraction described above.
</p>

<a name="History"></a><h2>History</h2>

<!--

Resumable Expressions
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4453.pdf

Coroutines belong in a TS
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0158r0.html

-->

<p>
As coroutines offer a powerful and performant programming model, an
important goal of WG21 is to finalize a coroutine specification suitable
for standardisation. Here we discuss the history of selected coroutine
proposals, and the current state of coroutines.
</p>



<a name="Discussion"></a><h2>Discussion</h2>



<a name="Solution"></a><h2>Solution</h2>



<a name="References"></a><h2>References</h2>

<b>[1]</b>
<a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/overview/core/coroutine.html">https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/overview/core/coroutine.html</a><br>
<br>

<b>[2]</b>
<a href="https://github.com/boostorg/beast/blob/93c35524a6125db3e6aeefc8abc826a810dd5d61/include/boost/beast/websocket/impl/read.ipp#L177">https://github.com/boostorg/beast/blob/93c35524a6125db3e6aeefc8abc826a810dd5d61/include/boost/beast/websocket/impl/read.ipp#L177</a><br>
<br>



<a name="Acknowledgements"></a><h2>Acknowledgements 1</h2>



<a name="Listing1"></a><h2>Listing 1</h2>
<tt><pre>
//
// Filename: "coroutine.hpp"
//

namespace detail {

struct coroutine_ref;

} // detail

struct coroutine
{
    coroutine() : line_(0) {}
    bool await_ready() const { return line_ == -1; }

private:
    friend struct detail::coroutine_ref;
    int line_;
};

namespace detail {

struct coroutine_ref
{
    coroutine_ref(coroutine& c) : line_(c.line_), modified_(false) {}
    ~coroutine_ref() { if (!modified_) line_ = -1; }
    operator int() const { return line_; }
    int& operator=(int v) { modified_ = true; return line_ = v; }

private:
    void operator=(coroutine_ref const&);

    int& line_;
    bool modified_;
};

} // detail

#define co_enter(c)                                  \
    switch (::detail::coroutine_ref _coro_value = c) \
    case -1: if (_coro_value)                        \
    {                                                \
        goto terminate_coroutine;                    \
        terminate_coroutine:                         \
        _coro_value = -1;                            \
        goto bail_out_of_coroutine;                  \
        bail_out_of_coroutine:                       \
        break;                                       \
    } else case 0:

#define _co-await_impl(n)                                                 \
        for (_coro_value = (n);;) if (_coro_value == 0) {                 \
    case (n): ; break; } else                                             \
        switch (_coro_value ? 0 : 1) for (;;)                             \
        case -1: if (_coro_value) goto terminate_coroutine; else for (;;) \
        case  1: if (_coro_value) goto bail_out_of_coroutine; else        \
        case  0:

#define co_await _co_await_impl(__LINE__)
</pre></tt>

</body>
</html>
